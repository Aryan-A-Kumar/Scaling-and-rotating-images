# -*- coding: utf-8 -*-
"""Exp-01-21EC39008.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BcmTyyvOAYuglsrGlMWSXM1OLwxXtHoC
"""
# This code works best in Google Colab!
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

path = 'Eye.jpg'

image = cv2.imread(path)
# Reading the image 


def display(image):
  cv2_imshow(image)
# Using cv2.imshow() method for Displaying the image

cv2_imshow(image)

def scale_nearest_neighbor(image, scale_factor):
  height, width, channels = image.shape
  scaled_height = int(height * scale_factor)
  scaled_width = int(width * scale_factor)
  scaled_image = np.zeros((scaled_height, scaled_width, channels), dtype=image.dtype)
  for i in range(scaled_height):
    for j in range(scaled_width):
      scaled_image[i, j] = image[int(i / scale_factor), int(j / scale_factor)]
  return scaled_image
# Scaling the image using nearest neighbors method

def scale_bilinear_interpolation(image, scale_factor):
  height, width, channels = image.shape
  scaled_height = int(height * scale_factor)
  scaled_width = int(width * scale_factor)
  scaled_image = np.zeros((scaled_height, scaled_width, channels), dtype=image.dtype)
  for i in range(scaled_height):
    for j in range(scaled_width):
      x = j / scale_factor
      y = i / scale_factor

      x0 = int(x)
      x1 = min(x0 + 1, width - 1)
      y0 = int(y)
      y1 = min(y0 + 1, height - 1)

      a = x - x0
      b = y - y0

      for c in range(channels):
          ## Considering four nearest pixels in the origial image and assigning the pixel value in the scaled image as the weighted mean of those values.
          value = (1 - a) * (1 - b) * image[y0, x0, c] + a * (1 - b) * image[y0, x1, c] + (1 - a) * b * image[y1, x0, c] + a * b * image[y1, x1, c]
          scaled_image[i, j, c] = int(value)
  return scaled_image
# Scaling the image using bilinear interpolation method

scaled_nn = scale_nearest_neighbor(image, 1.5)
scaled_bi = scale_bilinear_interpolation(image, 1.5)
# Scaling the image by a factor of 1.5

def save_image(image, file_path):
    cv2.imwrite(file_path, image)

save_image(scaled_nn, 'scaled_nn.jpg')
save_image(scaled_bi, 'scaled_bi.jpg')
# Saving the scaled images

def nearest_neighbor_rotation(image, angle):
    angle_rad = np.deg2rad(angle)
    height, width, channels = image.shape
    new_height = int(abs(width * np.sin(angle_rad)) + abs(height * np.cos(angle_rad)))
    new_width = int(abs(width * np.cos(angle_rad)) + abs(height * np.sin(angle_rad)))

    rotated_image = np.zeros((new_height, new_width, channels), dtype=image.dtype)
    cx, cy = width // 2, height // 2
    ncx, ncy = new_width // 2, new_height // 2

    for i in range(new_height):
        for j in range(new_width):
            x = (j - ncx) * np.cos(angle_rad) + (i - ncy) * np.sin(angle_rad) + cx
            y = -(j - ncx) * np.sin(angle_rad) + (i - ncy) * np.cos(angle_rad) + cy

            if 0 <= x < width and 0 <= y < height:
                rotated_image[i, j] = image[int(y), int(x)]

    return rotated_image
# Rotates an image by `angle` degrees clockwise using nearest neighbors method



def bilinear_rotation(image, angle):
    angle_rad = np.deg2rad(angle)
    height, width, channels = image.shape
    new_height = int(abs(width * np.sin(angle_rad)) + abs(height * np.cos(angle_rad)))
    new_width = int(abs(width * np.cos(angle_rad)) + abs(height * np.sin(angle_rad)))

    rotated_image = np.zeros((new_height, new_width, channels), dtype=image.dtype)
    cx, cy = width // 2, height // 2
    ncx, ncy = new_width // 2, new_height // 2

    for i in range(new_height):
        for j in range(new_width):
            x = (j - ncx) * np.cos(angle_rad) + (i - ncy) * np.sin(angle_rad) + cx
            y = -(j - ncx) * np.sin(angle_rad) + (i - ncy) * np.cos(angle_rad) + cy

            if 0 <= x < width and 0 <= y < height:
                x0 = int(x)
                x1 = min(x0 + 1, width - 1)
                y0 = int(y)
                y1 = min(y0 + 1, height - 1)

                a = x - x0
                b = y - y0

                for c in range(channels):
                    value = (1 - a) * (1 - b) * image[y0, x0, c] + a * (1 - b) * image[y0, x1, c] + (1 - a) * b * image[y1, x0, c] + a * b * image[y1, x1, c]
                    rotated_image[i, j, c] = int(value)

    return rotated_image
# Rotates an image by `angle` degrees clockwise using nearest neighbors method

rotated_bi = bilinear_rotation(image, 45)
rotated_nn = nearest_neighbor_rotation(image, 45)
# Rotating the image by 45 degrees

save_image(rotated_nn, 'rotated_nn.jpg')
save_image(rotated_bi, 'rotated_bi.jpg')
# Saving the rotated images

# Displaying the scaled and rotated images
display(scaled_nn)
display(scaled_bi)
display(rotated_nn)
display(rotated_bi)